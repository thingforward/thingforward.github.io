<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/blog</id>
  <link href="http://blog.url.com/blog"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2016-10-11T15:28:00+02:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Does REST for small devices make sense?</title>
    <link rel="alternate" href="http://blog.url.com/blog/2016/10/11/does-rest-for-small-devices-make-sense.html"/>
    <id>http://blog.url.com/blog/2016/10/11/does-rest-for-small-devices-make-sense.html</id>
    <published>2016-10-11T15:28:00+02:00</published>
    <updated>2016-10-20T13:55:24+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;When reading about maker projects, we often find case examples and remoting implementations using subsets of HTTP, i.e. requesting a status page from a RaspberryPi-based Sensor board or sending commands to small actor devices using HTTP-POST. There are quite a few blog posts and articles are about implementing a REST API on those small devices. Given that REST is well-known from the field of web development, we asked ouselves whether it would make sense to transfer REST capabilities to the field of embedded and IoT development.&lt;/p&gt;

&lt;h2 id="from-web-services-to-devices-services"&gt;From web services to devices services&lt;/h2&gt;

&lt;p&gt;When internet services offer access methods besides a browser-/HTML-based user interface, they often implement SOAP or apply REST as an architecture pattern. Both methods are about exchanging data and structured information between clients and (web) services in a network. The first, SOAP, is a standardized protocol whereas the latter, REST, is an architectural style and not a protocol.&lt;/p&gt;

&lt;p&gt;The REST-style approach has become very popular over the years, so developers often choose a combination of HTTP as a transport, JSON or XML as a format for exchanging data and a mix of characteristics and conventions that make up the RESTful architecture style. What are these characteristics, and can they also be applied to small IoT devices?&lt;/p&gt;

&lt;p&gt;But first: What do we mean by "small IoT devices"? A great many blog posts on this topic include SBCs such as the Raspberry Pi and comparable devices. These include multicore-processors capable of running operating systems such as Android, Linux or Windows IoT Core. They also run more or less the same software as found on servers, only with less computing power.
For this post we'd like to concentrate on really small, constrained devices: running on a single core processor, with only Kilobytes or sometimes Megabytes of Flash memory, and definitely not a full operating system such as Linux.&lt;/p&gt;

&lt;h2 id="rest-and-restful"&gt;REST and RESTful&lt;/h2&gt;

&lt;p&gt;The &lt;a href="https://en.wikipedia.org/wiki/Representational_state_transfer"&gt;Wikipedias article on REST&lt;/a&gt; states a number of architectural constraints. If a service fulfils these, it can be considered "RESTful". Maybe our small devices can also be RESTful.&lt;/p&gt;

&lt;p&gt;The first constraint regards the &lt;strong&gt;separation between client and server&lt;/strong&gt;, and thus the separation of a user interface, i.e. a Web UI. This can also be applied to IoT devices, i.e., when the data from a sensor is sent to a cloud service or when an App on a mobile device requests the triggering of an action on the constrained device. So maybe it's not about a "client" and "server" anymore, but still two (or more) parties exchanging data, and evolving independently of each other (as long as they adhere to the API contract).&lt;/p&gt;

&lt;p&gt;Next up are &lt;strong&gt;stateless&lt;/strong&gt; and &lt;strong&gt;cacheable&lt;/strong&gt; as important constraints for being RESTful. These requirements date back to a time when server-side application used to store a lot of client context data in server sessions, normally for a large number of clients. For constrained devices, this look easy. They simply do not have enough memory and processing capabilities to implement a server-side data storage, instead directly applying changes to physical properties: turning on a light, adjusting temperatures immediately upon request. It is not a problem to design statelessness into device behaviour. Clients can request a state-change on a device, and the device can immediately fulfill this request.&lt;/p&gt;

&lt;p&gt;The requirement &lt;strong&gt;layered system&lt;/strong&gt; can be fulfilled as well. Quite a number of IoT devices are not directly accessible (i.e., because of non-IP network stacks, different radio technologies, etc.), but are accessible via IoT gateways. So it's the gateway that represents a layer in the system, adding functionality to the overall solution.&lt;/p&gt;

&lt;p&gt;Next i'd like to look at the requirements for a &lt;strong&gt;uniform interface&lt;/strong&gt;.
The &lt;strong&gt;identification of resources&lt;/strong&gt; introduced a fundamental difference to accessing data within a web application. Developers are used to the convention that, for example, in an event store service, all events can be accessed by the URI &lt;code&gt;/events&lt;/code&gt;, and a single event with id 3512 under &lt;code&gt;/events/3512&lt;/code&gt;. This applies to devices as well when they are used to control different resources such as sensors and actors. Three LEDs can be accessed by, let's say &lt;code&gt;/led/1&lt;/code&gt;, &lt;code&gt;/led/2&lt;/code&gt; and &lt;code&gt;/led/3&lt;/code&gt;, as a very simple example. Resources are &lt;strong&gt;controlled by representations&lt;/strong&gt;, usually in some form of data format. For constrained devices, the choice of a data format is essential, as it is likely they can only supply a single data format, probably a binary one. This is in contrast to web services, which can easily produce and parse multiple representations, i.e., XML or JSON or HTML. So being on a very constrained environment, we'd have to make a choice here.&lt;/p&gt;

&lt;p&gt;A very interesting constraint impacts the hypermedia model and brings application state changes into the representation of content. This would apply to a service answer’s requests for  resources with content where further, possible actions are supplied in URLs (i.e. see &lt;a href="https://en.wikipedia.org/wiki/HATEOAS"&gt;HATEOAS&lt;/a&gt;).
It would allow a client to navigate through an application without knowledge about the content structure, because it is fully supplied within the hypermedia model.&lt;/p&gt;

&lt;p&gt;Constrained devices would also be capable of fulfilling this requirement. CoAP as an IoT protocol allows for the discovery of resources on a device, specified by the Constrained RESTful Environments (CoRE) Link Format, as specified by &lt;a href="https://tools.ietf.org/html/rfc6690"&gt;RFC6690&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="rest-for-constrained-devices"&gt;REST for constrained devices&lt;/h2&gt;

&lt;p&gt;Looking at the requirements of REST as an architectural style, we find that constrained devices are able to fulfil those, albeit on a much simpler level than web services do.&lt;/p&gt;

&lt;p&gt;At one of the next blog posts, we're going to look at CoAP, the Constrained Application Protocol and see how to implement a REST API on a small device!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>IoT Barcamp Notes</title>
    <link rel="alternate" href="http://blog.url.com/blog/2016/10/06/iot-barcamp-notes.html"/>
    <id>http://blog.url.com/blog/2016/10/06/iot-barcamp-notes.html</id>
    <published>2016-10-06T13:26:00+02:00</published>
    <updated>2016-10-20T13:56:19+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;On Tuesday, 4th October, Oliver and I participated in our first German bar camp
in Düsseldorf on the hype topic Internet of Things (IoT): &lt;a href="http://www.iotbarcamp.de/"&gt;www.iotbarcamp.de&lt;/a&gt;.
I would like to share my personal notes on the talks I heard and my general
impressions of the camp.&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/iotbarcamp_IMG_0249.jpeg" alt="w100" /&gt;&lt;/p&gt;

&lt;p&gt;The venue encompassed the entire floor in a modern office building located
in Düsseldorf Golzheim, in the heart of &lt;a href="https://www.google.de/maps/place/Bennigsen-Platz,+40474+D%C3%BCsseldorf/@51.2465369,6.7680377,17z/data=!3m1!4b1!4m5!3m4!1s0x47b8c9efeef2d93d:0x552bc10c24260333!8m2!3d51.2465369!4d6.7702264]"&gt;Düsseldorf's fashion district&lt;/a&gt;.
It was a large open space with enough room to move around, a number of tables
and chairs for taking breaks or to talk and work together with colleagues.
So far so good.&lt;/p&gt;

&lt;p&gt;The day progressed according to the time schedule starting with an introduction
by the organisers and the opportunity for everyone in the audience to introduce
himself/herself, together with three hashtag-like topics of one's own interests.
With 130 people I was quite worried about how long that would take, but everyone
managed to keep it short.&lt;/p&gt;

&lt;p&gt;The introduction round revealed a diverse set of interests around IoT: from business topics
(business models, ventures) through to UX design, platform building, hardware,
radio, smart cities, autonomous vehicles, security, prototyping, LORA.&lt;/p&gt;

&lt;p&gt;Session Planning was quite straight-forward: 23 session submissions, with 20
available slots. After a short debate, two sessions joined, and two more were
placed during the lunch break.&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/iotbarcamp_IMG_0252.jpeg" alt="w100" /&gt;&lt;/p&gt;

&lt;p&gt;Sascha Pallenberg’s keynote was intended to be live streamed (because of Sascha
being in Taipeh), but due to technical problems it was recorded and played back.
Sascha showed what "Smart City" really means being in Taipeh: autonoumous underground
trains, NFC payment being the norm and so on. Really interesting, especially when
comparing the situation to - lets say - countries like Germany.
Watch the recording &lt;a href="http://www.iotbarcamp.de/live/"&gt;on the barcamp live page&lt;/a&gt;, German-only.&lt;/p&gt;

&lt;p&gt;I had to hurry to finish my last slides for a session I was to give at 11:00,
about "Data formats for the IoT: Developing for embedded and web".
We researched different data formats and their efficiency with regards to size a
and compared to binary formats. For example, parsing JSON or even XML on an
embedded device can be really hard, whereas parsing the same structure in binary
form can be quite easy to code AND reduces data sizes when transmitting or storing.&lt;/p&gt;

&lt;p&gt;I wondered if this topic would fire up discussions in the audience: If it makes
sense, if it makes a difference, whether it is needed because it has already been
solved? I was not disappointed. We had a lively discussion covering a lot of
aspects, so obviously we raised a relevant topic.&lt;/p&gt;

&lt;p&gt;You can take a look at &lt;a href="https://speakerdeck.com/aschmidt75/iot-barcamp-data-formats-for-the-internet-of-things"&gt;my slides here&lt;/a&gt;.
This and other material will be the basis of our upcoming projects, so stay tuned :)&lt;/p&gt;

&lt;p&gt;The next session I visited was "IoT Service Kit" presented by &lt;a href="https://twitter.com/drbits"&gt;Michael Hufelschulte&lt;/a&gt;
from Cassini. The core idea is to have an offline "playground" to prototype mobile
and IoT solutions. The IoT is not only about software behind a web interface, and
not only about hardware gadgets either: It’s also about technology becoming ubiquitous,
so we should model and design the usage of it as well. The IoT service kit does that,
and Michael invited the audience around a table to design and run through a sample case.&lt;/p&gt;

&lt;p&gt;I was also happy to find a session about radio technology: Crowd sourced LPWAN,
LoraWAN and The Things Network,by &lt;a href="https://twitter.com/kgbvax"&gt;@kgbvax&lt;/a&gt;. I already
knew a bit about LORA and read about the underlying radio technology in the slide
presentation &lt;a href="http://static1.squarespace.com/static/54cecce7e4b054df1848b5f9/t/57489e6e07eaa0105215dc6c/1464376943218/Reversing-Lora-Knight.pdf"&gt;"Reversing LORA"&lt;/a&gt;)
but I still had some questions, such as what nodes to attach to a gateway, how to
code against it, costs, regulations etc. All answered, nice session!&lt;/p&gt;

&lt;p&gt;The last session i visited was "Selecting the right radio technology for IoT".
Lyn Matten from mm1 Technology introduced the various pitfalls that may arise
when selecting a radio technology for your own project, be it security,
energy consumption, regulations, internationalisation etc.
Bottom line: Know your requirements (as always :-) Slides: to be determined.&lt;/p&gt;

&lt;p&gt;&lt;img src="/img/iotbarcamp_IMG_0256.jpeg" alt="w100" /&gt;&lt;/p&gt;

&lt;p&gt;I'm still waiting for the session notes and the full list of links to the slides.
I hope they're going to be published by the barcamp team, so i can supply them to you.&lt;/p&gt;

&lt;p&gt;Looking forward to the next IoT Barcamp!&lt;/p&gt;

&lt;p&gt;Andreas&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Embedded Developers vs. Web Developers: some figures</title>
    <link rel="alternate" href="http://blog.url.com/blog/2016/09/28/embedded-developers-vs-web-developers-some-figures.html"/>
    <id>http://blog.url.com/blog/2016/09/28/embedded-developers-vs-web-developers-some-figures.html</id>
    <published>2016-09-28T02:00:00+02:00</published>
    <updated>2016-10-20T13:56:22+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;As we were doing some research we asked ourselves: How many skilled developers are ready to lead the way in the new era of IoT? Somebody has to implements all these billions of devices in a targeted way. Who are these people? And where are they hiding?&lt;/p&gt;

&lt;p&gt;We found two research studies. The first one is mentioned in &lt;a href="https://adtmag.com/Blogs/WatersWorks/2014/01/Worldwide-Developer-Count.aspx"&gt;a blog post&lt;/a&gt; from John K. Waters, citing the "2014 Worldwide Software Developer and ICT-Skilled Worker Estimates" report from IDC. We did not order the complete study, but John cites that there are 18.5 million software developers around the world, and about 11 million of those are professionals.&lt;/p&gt;

&lt;p&gt;That does not reveal the exact area of work, i.e., whether they are developing desktop applications, for the web or for mobile. But it did give us a real number of the overall community of developers.&lt;/p&gt;

&lt;p&gt;How many of those developers actually do embedded software development? Recent figures were hard to find. We did find a Slideshare presentation from a webcast of VDC Research (vdcresearch.com) about &lt;a href="http://de.slideshare.net/vdcresearch/searching-for-the-total-size-of-the-embedded-software-engineering-market"&gt;The total size of the embedded software engineering market&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Slide #9 estimates the world wide number of embedded engineers at 880,000 for the year 2010, with a year-to-year growth rate of approx. seven percent. Calculating this further to 2014 (making the comparison to the IDC figures above) would yield approximately 1.16 millions embedded engineers.&lt;/p&gt;

&lt;p&gt;Consequently, the number of professionals able to design and build IoT products is very likely to be much lower than, for example, those able to build web applications. Now building for embedded is truly different from building for the web, for a number of reasons as outlined in this &lt;a href="https://www.linkedin.com/pulse/5-differences-between-embedded-maharajan"&gt;Linked In article by the Electronic news&lt;/a&gt;, and in &lt;a href="http://www.embedded.com/electronics-news/4438618/10-skills-embedded-engineers-need-now"&gt;another post here&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Knowledge of underlying hardware and embedded operating systems&lt;/li&gt;
  &lt;li&gt;Control of software flow, scheduling and threading (and lack there-of)&lt;/li&gt;
  &lt;li&gt;Different programming languages&lt;/li&gt;
  &lt;li&gt;Testing and debugging, and much more&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Can web developers adopt a system engineering mindset? Will small devices be capable of hosting “web” services? Will they run dynamic, scripted languages? Would you want to learn C or C++ to code for embedded devices or rather wait for more convenient languages?&lt;/p&gt;

&lt;p&gt;Tell us what you think!
Andreas&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>ThingForward.io: Blog Kick-off</title>
    <link rel="alternate" href="http://blog.url.com/blog/2016/09/26/thingforward-io-blog-kick-off.html"/>
    <id>http://blog.url.com/blog/2016/09/26/thingforward-io-blog-kick-off.html</id>
    <published>2016-09-26T02:00:00+02:00</published>
    <updated>2016-10-20T13:56:26+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">
&lt;p&gt;Every blog has to start with a first post, so this one kicks off our blog journey into the software development of IoT – bringing together software development patterns from the Internet world and the world of Things!&lt;/p&gt;

&lt;p&gt;We really started this journey back in 2014 when we started designing and developing software for small, embedded devices. It was like a trip back in time. The majority of embedded IoT devices we came across were really “constrained”: small, 32-bit MCUs with only a few hundred KBs or at most 1-2 MBs of Flash, and sometimes even less SRAM to work with.&lt;/p&gt;

&lt;p&gt;Given the equipment and configuration of chip modules, using C or C++ was and still is the primary way to program these devices. Of course there are a number of projects aiming to bring scripted languages such as JS and Python in the pipeline, but coding for professional products at the moment is still most likely done in plain C or C++. However, when it comes to optimization (whether for speed or battery consumption), the results can be quite sub-standard. It reminds me of the phrase “security by obscurity”, where you hide things with the aim of making your solution more secure - because nobody understands how to access it. As you might imagine, this is not very fruitful. When I look at highly optimized C code, I can see a lot of similarities.&lt;/p&gt;

&lt;p&gt;Unfortunately, this kind of optimization makes a number of things worse, i.e., when writing unit tests for your code, or even when trying to integrate new team members to the stack. Coming from the software development for the web world, we were used to having fully automated build and integration testing systems, with code using third party libraries from the OSS sphere, each one with its documentation and unit tests and so forth.
Now, developing for the embedded world, we find ourselves once again thrown back to an ancient IT era, where many things still need to be done manually.&lt;/p&gt;

&lt;p&gt;Our primary concern is about communication within the Internet of Things. In this (probably exponentially) growing network, devices need to be able to communicate with each other. This not only includes the capabilities to “speak” the same radio protocol (WiFi, ZigBee, LoRa, etc), but also touches on other aspects of the software application layer: Protocols and Data Formats, covering layers 5 to 7 of the OSI stack.&lt;/p&gt;

&lt;p&gt;Our aim is to improve software development for the latter aspects. We feel that IoT solutions need to be open and compatible when it comes to data communication. We want to give IoT developers and IoT architects valuable tools that help them simplify their embedded projects and thus speed up their development lifecycles.&lt;/p&gt;

&lt;p&gt;In this blog we’re going to explore technical issues around embedded software development, testing devices, creating service layers and using embedded protocols and data formats. We hope we’re able to deliver valuable assets for IoT and embedded developers. Let us know what you think!&lt;/p&gt;

&lt;p&gt;Best,
Andreas and Oliver&lt;/p&gt;
</content>
  </entry>
</feed>
